<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="chartStyles.css">
<link rel="stylesheet" href="groupStyles.css">
<body>
<div id="container">
    <div id="title">
        <div id="head">Stock Viz Helper</div>
        <select class="dropdown">

        </select>
    </div>

    <div id="Chart">

    </div>

    <div id="technicalIndicators">
        <!-- Group 1 for main options -->
        <div id="options-group1" class="options-group">
            <div class="group-title">Technical Indicator</div>
            <form>
                <label><input type="checkbox" id="volumeCheckbox"> Volume</label><br>
                <label><input type="checkbox" id="candlestickCheckbox"> CandleStick</label><br>
                <label><input type="checkbox" id="movingAverageCheckbox"> Moving Average</label><br>
                <label><input type="checkbox" id="macdCheckbox"> MACD</label><br>
                <label><input type="checkbox" id="rsiCheckbox"> RSI</label><br>
            </form>

        </div>
    </div>
    <!-- Group 2 for additional options -->
    <div id="toolbox">
        <div id="options-group2" class="options-group">
            <div class="group-title">Toolbox</div>
            <form>
                <label><input type="checkbox" id="trendlineCheckbox"> Trendlines</label><br>
                <label><input type="checkbox" id="supstanceCheckbox"> Supstances</label><br>
                <label><input type="checkbox" id="tradearrowCheckbox"> Trade Arrows</label><br>
            </form>
        </div>
    </div>

    <div id="explanationBox">

    </div>
</div>


<script src="http://d3js.org/d3.v4.min.js"></script>
<script src="http://techanjs.org/techan.min.js"></script>
<script>

    /*
    *
    * Company Dropdown
    *
    * */



    /*
    *
    *  Indicators & Toolbox
    *
    * */
    var dim = {
        width: 960, height: 500,
        margin: {top: 20, right: 50, bottom: 30, left: 50},
        ohlc: {height: 305},
        indicator: {height: 65, padding: 5}
    };
    dim.plot = {
        width: dim.width - dim.margin.left - dim.margin.right,
        height: dim.height - dim.margin.top - dim.margin.bottom
    };
    dim.indicator.top = dim.ohlc.height + dim.indicator.padding;
    dim.indicator.bottom = dim.indicator.top + dim.indicator.height + dim.indicator.padding;

    var indicatorTop = d3.scaleLinear()
        .range([dim.indicator.top, dim.indicator.bottom]);

    // var parseDate = d3.timeParse("%d-%b-%y");
    // var parseDate = d3.timeParse("%Y/%m/%d");
    var parseDate = d3.timeParse("%Y-%m-%d");


    var zoom = d3.zoom()
        .on("zoom", zoomed);

    var x = techan.scale.financetime()
        .range([0, dim.plot.width]);

    var y = d3.scaleLinear()
        .range([dim.ohlc.height, 0]);


    var yPercent = y.copy();   // Same as y at this stage, will get a different domain later

    var yInit, yPercentInit, zoomableInit;

    var yVolume = d3.scaleLinear()
        .range([y(0), y(0.2)]);

    var candlestick = techan.plot.candlestick()
        .xScale(x)
        .yScale(y);

    var tradearrow = techan.plot.tradearrow()
        .xScale(x)
        .yScale(y)
        .y(function (d) {
            // Display the buy and sell arrows a bit above and below the price, so the price is still visible
            if (d.type === 'buy') return y(d.low);
            if (d.type === 'sell') return y(d.high);
            else return y(d.price);
        });

    var sma0 = techan.plot.sma()
        .xScale(x)
        .yScale(y);

    var sma1 = techan.plot.sma()
        .xScale(x)
        .yScale(y);

    var ema2 = techan.plot.ema()
        .xScale(x)
        .yScale(y);

    var volume = techan.plot.volume()
        .accessor(candlestick.accessor())   // Set the accessor to a ohlc accessor so we get highlighted bars
        .xScale(x)
        .yScale(yVolume);

    var trendline = techan.plot.trendline()
        .xScale(x)
        .yScale(y);

    var supstance = techan.plot.supstance()
        .xScale(x)
        .yScale(y);

    var xAxis = d3.axisBottom(x);

    var timeAnnotation = techan.plot.axisannotation()
        .axis(xAxis)
        .orient('bottom')
        .format(d3.timeFormat('%Y/%m/%d'))
        .width(65)
        .translate([0, dim.plot.height]);

    var yAxis = d3.axisRight(y);

    var ohlcAnnotation = techan.plot.axisannotation()
        .axis(yAxis)
        .orient('right')
        .format(d3.format(',.2f'))
        .translate([x(1), 0]);

    var closeAnnotation = techan.plot.axisannotation()
        .axis(yAxis)
        .orient('right')
        .accessor(candlestick.accessor())
        .format(d3.format(',.2f'))
        .translate([x(1), 0]);

    var percentAxis = d3.axisLeft(yPercent)
        .tickFormat(d3.format('+.1%'));

    var percentAnnotation = techan.plot.axisannotation()
        .axis(percentAxis)
        .orient('left');

    var volumeAxis = d3.axisRight(yVolume)
        .ticks(3)
        .tickFormat(d3.format(",.3s"));

    var volumeAnnotation = techan.plot.axisannotation()
        .axis(volumeAxis)
        .orient("right")
        .width(35);

    var macdScale = d3.scaleLinear()
        .range([indicatorTop(0) + dim.indicator.height, indicatorTop(0)]);

    var rsiScale = macdScale.copy()
        .range([indicatorTop(1) + dim.indicator.height, indicatorTop(1)]);

    var macd = techan.plot.macd()
        .xScale(x)
        .yScale(macdScale);

    var macdAxis = d3.axisRight(macdScale)
        .ticks(3);

    var macdAnnotation = techan.plot.axisannotation()
        .axis(macdAxis)
        .orient("right")
        .format(d3.format(',.2f'))
        .translate([x(1), 0]);

    var macdAxisLeft = d3.axisLeft(macdScale)
        .ticks(3);

    var macdAnnotationLeft = techan.plot.axisannotation()
        .axis(macdAxisLeft)
        .orient("left")
        .format(d3.format(',.2f'));

    var rsi = techan.plot.rsi()
        .xScale(x)
        .yScale(rsiScale);

    var rsiAxis = d3.axisRight(rsiScale)
        .ticks(3);

    var rsiAnnotation = techan.plot.axisannotation()
        .axis(rsiAxis)
        .orient("right")
        .format(d3.format(',.2f'))
        .translate([x(1), 0]);

    var rsiAxisLeft = d3.axisLeft(rsiScale)
        .ticks(3);

    var rsiAnnotationLeft = techan.plot.axisannotation()
        .axis(rsiAxisLeft)
        .orient("left")
        .format(d3.format(',.2f'));

    var ohlcCrosshair = techan.plot.crosshair()
        .xScale(timeAnnotation.axis().scale())
        .yScale(ohlcAnnotation.axis().scale())
        .xAnnotation(timeAnnotation)
        .yAnnotation([ohlcAnnotation, percentAnnotation, volumeAnnotation])
        .verticalWireRange([0, dim.plot.height]);

    var macdCrosshair = techan.plot.crosshair()
        .xScale(timeAnnotation.axis().scale())
        .yScale(macdAnnotation.axis().scale())
        .xAnnotation(timeAnnotation)
        .yAnnotation([macdAnnotation, macdAnnotationLeft])
        .verticalWireRange([0, dim.plot.height]);

    var rsiCrosshair = techan.plot.crosshair()
        .xScale(timeAnnotation.axis().scale())
        .yScale(rsiAnnotation.axis().scale())
        .xAnnotation(timeAnnotation)
        .yAnnotation([rsiAnnotation, rsiAnnotationLeft])
        .verticalWireRange([0, dim.plot.height]);

    // var ichimoku = techan.plot.ichimoku()
    //         .xScale(x)
    //         .yScale(y);

    var svg = d3.select("#Chart").append("svg")
        .attr("width", dim.width)
        .attr("height", dim.height);


    var defs = svg.append("defs");

    defs.append("clipPath")
        .attr("id", "ohlcClip")
        .append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", dim.plot.width)
        .attr("height", dim.ohlc.height);

    defs.selectAll("indicatorClip").data([0, 1])
        .enter()
        .append("clipPath")
        .attr("id", function (d, i) {
            return "indicatorClip-" + i;
        })
        .append("rect")
        .attr("x", 0)
        .attr("y", function (d, i) {
            return indicatorTop(i);
        })
        .attr("width", dim.plot.width)
        .attr("height", dim.indicator.height);

    svg = svg.append("g")
        .attr("transform", "translate(" + dim.margin.left + "," + dim.margin.top + ")");

    // svg.append('text')
    //     .attr("class", "symbol")
    //     .attr("x", 20)
    //     .text("Facebook, Inc. (FB)");

    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + dim.plot.height + ")");

    var ohlcSelection = svg.append("g")
        .attr("class", "ohlc")
        .attr("transform", "translate(0,0)");

    ohlcSelection.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + x(1) + ",0)")
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -12)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Price ($)");

    ohlcSelection.append("g")
        .attr("class", "close annotation up");

    ohlcSelection.append("g")
        .attr("class", "volume")
        .attr("clip-path", "url(#ohlcClip)");

    ohlcSelection.append("g")
        .attr("class", "candlestick")
        .attr("clip-path", "url(#ohlcClip)");

    ohlcSelection.append("g")
        .attr("class", "indicator sma ma-0")
        .attr("clip-path", "url(#ohlcClip)");

    ohlcSelection.append("g")
        .attr("class", "indicator sma ma-1")
        .attr("clip-path", "url(#ohlcClip)");

    ohlcSelection.append("g")
        .attr("class", "indicator ema ma-2")
        .attr("clip-path", "url(#ohlcClip)");

    ohlcSelection.append("g")
        .attr("class", "percent axis");

    ohlcSelection.append("g")
        .attr("class", "volume axis");

    var indicatorSelection = svg.selectAll("svg > g.indicator").data(["macd", "rsi"]).enter()
        .append("g")
        .attr("class", function (d) {
            return d + " indicator";
        });

    indicatorSelection.append("g")
        .attr("class", "axis right")
        .attr("transform", "translate(" + x(1) + ",0)");

    indicatorSelection.append("g")
        .attr("class", "axis left")
        .attr("transform", "translate(" + x(0) + ",0)");

    indicatorSelection.append("g")
        .attr("class", "indicator-plot")
        .attr("clip-path", function (d, i) {
            return "url(#indicatorClip-" + i + ")";
        });

    // Add trendlines and other interactions last to be above zoom pane
    svg.append('g')
        .attr("class", "crosshair ohlc");

    svg.append("g")
        .attr("class", "tradearrow")
        .attr("clip-path", "url(#ohlcClip)");

    svg.append('g')
        .attr("class", "crosshair macd");

    svg.append('g')
        .attr("class", "crosshair rsi");

    svg.append("g")
        .attr("class", "trendlines analysis")
        .attr("clip-path", "url(#ohlcClip)");
    svg.append("g")
        .attr("class", "supstances analysis")
        .attr("clip-path", "url(#ohlcClip)");
    // svg.append("g")
    //         .attr("class", "ichimoku")
    //         .attr("clip-path", "url(#ohlcClip)");

    d3.select("button").on("click", clearAllCheckboxes);

    const companyMap = {
        "AAPL": "Apple Inc.",
        "ADBE": "Adobe Inc.",
        "AMD": "Advanced Micro Devices, Inc.",
        "AMZN": "Amazon.com, Inc.",
        "CRM": "Salesforce, Inc.",
        "CSCO": "Cisco Systems, Inc.",
        "DDOG": "Datadog, Inc.",
        "DOCU": "DocuSign, Inc.",
        "GOOG": "Alphabet Inc. (Class C)",
        "GOOGL": "Alphabet Inc. (Class A)",
        "IBM": "International Business Machines Corporation",
        "INTC": "Intel Corporation",
        "MDB": "MongoDB, Inc.",
        "META": "Meta Platforms, Inc. (formerly known as Facebook, Inc.)",
        "MSFT": "Microsoft Corporation",
        "NFLX": "Netflix, Inc.",
        "NVDA": "NVIDIA Corporation",
        "PYPL": "PayPal Holdings, Inc.",
        "SHOP": "Shopify Inc.",
        "MQ": "Marqeta, Inc."
    };



    /*
     *
     * Nov. 11
     * Author: Lance
     * Comment: Modified the csv reading function and integrated into createElement().
     *          The graph displays incorrectly.
     *          Uncomment the following two functions and comment out the original d3.csv() to test.
     *
     *
     * */
     function removeTrendlines() {
        svg.select(".trendlines").selectAll("*").remove();
    }
        
    d3.csv("../stock_data/combined_stocks.csv", function (data) {

        // get company list
        var companyList = Array.from(new Set(data.map(d => d.Company))).sort();
        // add options to Button

        var dropdown = d3.select(".dropdown");

        dropdown.append("option")
                .text("Select a stock")
                .attr("value", "")
                .attr("disabled", true)
                .attr("selected", true)

        dropdown.selectAll('option.company')
            .data(companyList) // take companyList
            .enter()
            .append("option")
            .classed("company", true)
            .text(d => d)
            .attr("value", d => d);

        d3.select(".dropdown").on("change", function () {
            removeTrendlines(); 
            var filteredData = data.filter(d => d.Company == this.value);
            console.log("Comapny", this.value)
            console.log("filteredData", filteredData);
            // Assuming the data is already sorted by date, find the last date in your dataset
            var lastDate = d3.max(filteredData, function(d) { return parseDate(d.Date); });
            // Calculate the first date of the last year (most recent year)
            var firstDateOfLastYear = new Date(lastDate.getFullYear() - 1, lastDate.getMonth(), lastDate.getDate());
            // Filter the data to only include entries from the most recent year
            var one_year_data = filteredData.filter(function(d) {
                return parseDate(d.Date) >= firstDateOfLastYear;
            });
            d3.select(".symbol").remove();

            svg.append('text')
                .attr("class", "symbol")
                .attr("x", 20)
                .text(companyMap[this.value]);
            console.log("lastDate", lastDate)
            console.log("firstDateOfLastYear", firstDateOfLastYear)
            console.log("one_year_data", one_year_data);
            createElement(one_year_data);
        });
    });


    function createElement(data) {
        var accessor = candlestick.accessor(),
        indicatorPreRoll = 33;  // Don't show where indicators don't have data
        data = data.map(function (d) {
            return {
                date: parseDate(d.Date),
                open: +d.Open,
                high: +d.High,
                low: +d.Low,
                close: +d.Close,
                volume: +d.Volume
            };
        }).sort(function (a, b) {
            return d3.ascending(accessor.d(a), accessor.d(b));
        });

        console.log("data", data);
        x.domain(techan.scale.plot.time(data).domain());
        y.domain(techan.scale.plot.ohlc(data.slice(indicatorPreRoll)).domain());
        console.log("ohlc domain", techan.scale.plot.ohlc(data.slice(indicatorPreRoll)).domain())
        yPercent.domain(techan.scale.plot.percent(y, accessor(data[indicatorPreRoll])).domain());
        yVolume.domain(techan.scale.plot.volume(data).domain());

        // var trendlineData = [
        //     {start: {date: new Date(2014, 2, 11), value: 72.50}, end: {date: new Date(2014, 5, 9), value: 63.34}},
        //     {start: {date: new Date(2013, 10, 21), value: 43}, end: {date: new Date(2014, 2, 17), value: 70.50}}
        // ];

        // var supstanceData = [
        //     {start: new Date(2014, 2, 11), end: new Date(2014, 5, 9), value: 63.64},
        //     {start: new Date(2013, 10, 21), end: new Date(2014, 2, 17), value: 55.50}
        // ];

        /*var trades_ = [
             {date: data[67].date, type: "buy", price: data[67].low, low: data[67].low, high: data[67].high},
             {date: data[100].date, type: "sell", price: data[100].high, low: data[100].low, high: data[100].high},
             {date: data[130].date, type: "buy", price: data[130].low, low: data[130].low, high: data[130].high},
             {date: data[139].date, type: "sell", price: data[139].low, low: data[139].low, high: data[139].high}
        ];
        console.log("trades_", trades_) */
        
        // Dynamically create trendline data
        console.log("x", x.domain())
        console.log("x first", x.domain()[0])
        console.log("x last", x.domain()[x.domain().length - 1])
        console.log("x length", x.domain().length)
        console.log("y", y.domain())
        var trendlineData = createTrendlineData(data, x, y);
        console.log("trendlineData", trendlineData)
        // Dynamically create supstance data
        var supstanceData = createSupstanceData(data);
        console.log("supstanceData", supstanceData)
        // Dynamically create trade data
        var trades = createTrades(data);
        // console.log("trades", trades)

        var macdData = techan.indicator.macd()(data);
        macdScale.domain(techan.scale.plot.macd(macdData).domain());
        var rsiData = techan.indicator.rsi()(data);
        rsiScale.domain(techan.scale.plot.rsi(rsiData).domain());


        svg.select("g.candlestick").datum(data).call(candlestick);
        svg.select("g.close.annotation").datum([data[data.length - 1]]).call(closeAnnotation);
        svg.select("g.volume").datum(data).call(volume);
        svg.select("g.sma.ma-0").datum(techan.indicator.sma().period(10)(data)).call(sma0);
        svg.select("g.sma.ma-1").datum(techan.indicator.sma().period(20)(data)).call(sma1);
        svg.select("g.ema.ma-2").datum(techan.indicator.ema().period(50)(data)).call(ema2);
        svg.select("g.macd .indicator-plot").datum(macdData).call(macd);
        svg.select("g.rsi .indicator-plot").datum(rsiData).call(rsi);

        svg.select("g.crosshair.ohlc").call(ohlcCrosshair).call(zoom);
        svg.select("g.crosshair.macd").call(macdCrosshair).call(zoom);
        svg.select("g.crosshair.rsi").call(rsiCrosshair).call(zoom);
        svg.select("g.trendlines").datum(trendlineData).call(trendline).call(trendline.drag);
        svg.select("g.supstances").datum(supstanceData).call(supstance).call(supstance.drag);

        svg.select("g.tradearrow").datum(trades).call(tradearrow);
        // Stash for zooming
        zoomableInit = x.zoomable().domain([indicatorPreRoll, data.length]).copy(); // Zoom in a little to hide indicator preroll
        yInit = y.copy();
        yPercentInit = yPercent.copy();

        draw();
    }

    function reset() {
        // zoom.scale(1);
        // zoom.translate([0,0]);
        draw();
    }

    function zoomed() {
        x.zoomable().domain(d3.event.transform.rescaleX(zoomableInit).domain());
        y.domain(d3.event.transform.rescaleY(yInit).domain());
        yPercent.domain(d3.event.transform.rescaleY(yPercentInit).domain());
        draw();
    }

    function draw() {
        svg.select("g.x.axis").call(xAxis);
        svg.select("g.ohlc .axis").call(yAxis);
        svg.select("g.volume.axis").call(volumeAxis);
        svg.select("g.percent.axis").call(percentAxis);
        svg.select("g.macd .axis.right").call(macdAxis);
        svg.select("g.rsi .axis.right").call(rsiAxis);
        svg.select("g.macd .axis.left").call(macdAxisLeft);
        svg.select("g.rsi .axis.left").call(rsiAxisLeft);

        // We know the data does not change, a simple refresh that does not perform data joins will suffice.
        svg.select("g.candlestick").call(candlestick.refresh);
        svg.select("g.close.annotation").call(closeAnnotation.refresh);
        svg.select("g.volume").call(volume.refresh);
        svg.select("g .sma.ma-0").call(sma0.refresh);
        svg.select("g .sma.ma-1").call(sma1.refresh);
        svg.select("g .ema.ma-2").call(ema2.refresh);
        svg.select("g.macd .indicator-plot").call(macd.refresh);
        svg.select("g.rsi .indicator-plot").call(rsi.refresh);
        svg.select("g.crosshair.ohlc").call(ohlcCrosshair.refresh);
        svg.select("g.crosshair.macd").call(macdCrosshair.refresh);
        svg.select("g.crosshair.rsi").call(rsiCrosshair.refresh);
        svg.select("g.trendlines").call(trendline.refresh);
        svg.select("g.supstances").call(supstance.refresh);
        svg.select("g.tradearrow").call(tradearrow.refresh);
    }

    document.getElementById('volumeCheckbox').addEventListener('change', function () {
        svg.selectAll(".volume").style("display", this.checked ? null : "none");
    });

    document.getElementById('candlestickCheckbox').addEventListener('change', function () {
        svg.selectAll(".candlestick").style("display", this.checked ? null : "none");
    });

    document.getElementById('movingAverageCheckbox').addEventListener('change', function () {
        svg.selectAll(".sma").style("display", this.checked ? null : "none");
        svg.selectAll(".ema").style("display", this.checked ? null : "none"); // Assuming EMA is also a moving average
    });

    document.getElementById('macdCheckbox').addEventListener('change', function () {
        svg.selectAll(".macd").style("display", this.checked ? null : "none");
    });

    document.getElementById('rsiCheckbox').addEventListener('change', function () {
        svg.selectAll(".rsi").style("display", this.checked ? null : "none");
    });

    document.getElementById('trendlineCheckbox').addEventListener('change', function () {
        svg.selectAll(".trendlines").style("display", this.checked ? null : "none");
    });

    // Event listener for the supstance checkbox
    document.getElementById('supstanceCheckbox').addEventListener('change', function () {
        svg.selectAll(".supstances").style("display", this.checked ? null : "none");
    });

    // Event listener for the tradearrow checkbox
    document.getElementById('tradearrowCheckbox').addEventListener('change', function () {
        svg.selectAll(".tradearrow").style("display", this.checked ? null : "none");
    });

    // Assuming you have an element for Ichimoku Cloud, which might not be the case.
    // If you don't, you will need to implement the rendering for it first.
    // document.getElementById('ichimokuCloudCheckbox').addEventListener('change', function() {
    //     svg.selectAll(".ichimoku").style("display", this.checked ? null : "none"); // Replace ".ichimoku" with your actual Ichimoku Cloud class or group
    // });

    // Call this function initially to apply the checkbox states to the chart elements
    function applyInitialCheckboxStates() {
        document.getElementById('volumeCheckbox').dispatchEvent(new Event('change'));
        document.getElementById('candlestickCheckbox').dispatchEvent(new Event('change'));
        document.getElementById('movingAverageCheckbox').dispatchEvent(new Event('change'));
        document.getElementById('macdCheckbox').dispatchEvent(new Event('change'));
        document.getElementById('rsiCheckbox').dispatchEvent(new Event('change'));
        document.getElementById('trendlineCheckbox').dispatchEvent(new Event('change'));
        document.getElementById('supstanceCheckbox').dispatchEvent(new Event('change'));
        document.getElementById('tradearrowCheckbox').dispatchEvent(new Event('change'));
        // document.getElementById('ichimokuCloudCheckbox').dispatchEvent(new Event('change'));
    }

    // Call this function after the chart and checkboxes are initialized to set the initial states
    applyInitialCheckboxStates();

    function clearAllCheckboxes() {
        var checkboxes = document.querySelectorAll('form input[type="checkbox"]');
        checkboxes.forEach(function (checkbox) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change'));
        });
        // Call any additional functions to update the chart here if necessary
    }

    function createTrendlineData(data) {
        // Assuming data is sorted by date ascending
        // Find the lowest low and highest high for the positive slope
        let low = data.reduce((min, p) => p.low < min.low ? p : min, data[0]);
        let high = data.reduce((max, p) => p.high > max.high ? p : max, data[0]);
    
        // For the negative slope, find the high and then the lowest low after that high
        let highForNegative = high;
        let lowAfterHighForNegative = data.slice(data.indexOf(highForNegative)).reduce((min, p) => p.low < min.low ? p : min, highForNegative);
    
        // Create two trendlines
        let positiveSlopeTrendline = {
            start: { date: low.date, value: low.low },
            end: { date: high.date, value: high.high }
        };
    
        let negativeSlopeTrendline = {
            start: { date: highForNegative.date, value: highForNegative.high },
            end: { date: lowAfterHighForNegative.date, value: lowAfterHighForNegative.low }
        };
    
        return [positiveSlopeTrendline, negativeSlopeTrendline];
    }
    
    function createSupstanceData(data, tolerancePercentage = 10) {
        let groupedLevels = {};
    
        // Group price levels that are within a certain percentage of each other
        data.forEach(d => {
            let levels = [d.high, d.low];
    
            levels.forEach(level => {
                let foundGroup = false;
    
                for (let groupedLevel in groupedLevels) {
                    let groupedPrice = parseFloat(groupedLevel);
    
                    // Define tolerance range for grouping
                    let tolerance = groupedPrice * tolerancePercentage / 100;
    
                    // If the level is within the tolerance range, group it
                    if (level >= groupedPrice - tolerance && level <= groupedPrice + tolerance) {
                        groupedLevels[groupedLevel].count++;
                        groupedLevels[groupedLevel].prices.push(level);
                        foundGroup = true;
                        break;
                    }
                }
    
                // If level didn't fit into any group, create a new group
                if (!foundGroup) {
                    groupedLevels[level] = { count: 1, prices: [level] };
                }
            });
        });
    
        // Convert grouped levels into an array and sort by count
        let sortedGroups = Object.keys(groupedLevels)
            .map(price => ({
                price: parseFloat(price),
                count: groupedLevels[price].count,
                averagePrice: d3.mean(groupedLevels[price].prices)
            }))
            .sort((a, b) => b.count - a.count);
    
        // Take the start and end dates from the dataset
        let startDate = data[0].date;
        let endDate = data[data.length - 1].date;
    
        // Map sorted groups to supstance data
        let supstances = sortedGroups.map(group => ({
            start: startDate,
            end: endDate,
            value: group.averagePrice
        }));
    
        return supstances;
    }
                
    function createTrades(data) {
        // Simple moving average crossover strategy
        let smaPeriodShort = 10;
        let smaPeriodLong = 20;
    
        let smaShort = calculateSMA(data, smaPeriodShort);
        let smaLong = calculateSMA(data, smaPeriodLong);
    
        let trades = [];
    
        for (let i = 1; i < data.length; i++) {
            if (smaShort[i] > smaLong[i] && smaShort[i - 1] <= smaLong[i - 1]) {
                trades.push({ date: data[i].date, type: "buy", price: data[i].close, low: data[i].low, high: data[i].high});
            } else if (smaShort[i] < smaLong[i] && smaShort[i - 1] >= smaLong[i - 1]) {
                trades.push({ date: data[i].date, type: "sell", price: data[i].close, low: data[i].low, high: data[i].high});
            }
        }
    
        return trades;
    }
    
    function calculateSMA(data, period) {
        let sma = data.map(d => d.close).map((elem, index, arr) => {
            let start = Math.max(0, index - period + 1);
            let subset = arr.slice(start, index + 1);
            let sum = subset.reduce((a, b) => a + b, 0);
            return sum / subset.length;
        });
    
        return sma;
    }
    

</script>